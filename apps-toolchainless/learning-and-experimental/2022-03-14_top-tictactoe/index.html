<!doctype html>

<!--
Filename: index.html
Author:   simshadows <contact@simshadows.com>
License:  GNU Affero General Public License v3 (AGPL-3.0)

See the root page for a link to the source code.
-->

<html>
<head>
    <title>Simple Tic-Tac-Toe</title>
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1">
    <link rel="stylesheet" type="text/css" href="./index.css">
    <script defer src="./index.js"></script>
</head>

<body>

<div id="app">
    <div id="play-area"></div>
    <div id="bottom-bar"></div>
</div>

<p>
    This web app follows <a href="https://www.theodinproject.com/paths/full-stack-javascript/courses/javascript/lessons/tic-tac-toe">Project: Tic Tac Toe</a> from <a href="https://www.theodinproject.com/">The Odin Project</a>, including the AI extension criteria.
</p>
<p>
    This app wasn't designed with mobile in mind.
</p>
<p>
    Six different AI players are implemented:
    <ul>
        <li><b>Hard:</b> Perfect gameplay algorithm that goes through a priority rule list.</li>
        <ul>
            <li>Implemented using the expert system algorithm outlined in <em><a href="https://doi.org/10.1207/s15516709cog1704_3">Flexible Strategy Use in Young Children's Tic-Tac-Toe</a></em> by Kevin Crowley and Robert S. Siegler.</li>
            <li>The algorithm follows a priority rule list:</li>
            <ul>
                <li>Rule 1: The AI checks if it can win on the current turn. If so, it takes the win. If not, it tries the next rule.</li>
                <li>Rule 2: The AI checks if its opponent can win on the current turn. If so, it blocks the opponent from winning. If not, it tries the next rule.</li>
                <li>Rule 3: The AI checks if it can set up a <em>fork</em>. If so, then it will do so. If not, it tries the next rule.</li>
                <ul>
                    <li>A <em>fork</em> is a situation where the "forking player" can guarantee a win the turn after the fork situation was create.</li>
                </ul>
                <li>Rule 4: The AI checks if its opponent can set up a fork on its turn. If so, then it will block it. If not, it tries the next rule.</li>
                <ul>
                    <li>To block its opponent's fork, the AI will first attempt to create a "line-of-two" to force its opponent to block it, taking care so when its opponent blocks, it doesn't inadvertently let the opponent create a fork.</li>
                    <li>If creating a valid "line-of-two" isn't possible, then the AI will simply place its marker on a square such that its opponent can no longer set up a fork.</li>
                </ul>
                <li>Rule 5: The AI will attempt to place its marker at the center. If it can't, it tries the next rule.</li>
                <li>Rule 6: The AI will attempt to place its marker at the opposite corner of an opponent's corner marker, if such a position exists. If it can't, it tries the next rule.</li>
                <li>Rule 7: The AI will attempt to place its marker at an empty corner. If it can't, then it moves to the final rule.</li>
                <li>Rule 8: The AI will attempt to place its marker at an empty side.</li>
            </ul>
        </ul>
        <li><b>Medium (Shallow):</b> An intelligent but flawed AI whose weakness is that it only looks one step ahead.</li>
        <ul>
            <li>Also implemented using an expert system algorithm that goes through a simple priority rule list.</li>
            <li>The algorithm follows a priority rule list:</li>
            <ul>
                <li>Rule 1: The AI checks if it can win on the current turn. If so, it takes the win. If not, it tries the next rule.</li>
                <li>Rule 2: The AI checks if its opponent can win on the current turn. If so, it blocks at least one of its opponent's possible winning moves (even if it's a <em>fork</em>). If not, it tries the next rule.</li>
                <li>Rule 3: The AI checks if there's any possible path to victory. If so, then it will try to "win as fast as possible", favouring lines that already contain its own marker. If there are no possible lines to victory, then it moves to the final rule.</li>
                <li>Rule 4: The AI picks any random empty square.</li>
            </ul>
        </ul>
        <li><b>Medium (Random):</b> A sabotaged version of <em>Hard</em> that has a chance of playing poorly on each turn.</li>
        <ul>
            <li>During each turn, there's a 70% chance of playing like <em>Hard</em>, and a 30% chance of playing like <em>Easy</em>.</li>
        </ul>
        <li><b>Easy:</b> Picks any empty square at random. All empty squares have equal probabilities of being chosen.</li>
        <li><b>Minimax:</b> Cannot lose. Takes advantage of guaranteed wins, or forces a draw if it can't.</li>
        <ul>
            <li>Implemented using the minimax algorithm.</li>
            <li>This AI may sometimes choose not to take a win on the next turn, but (I believe) it will only do so if it can guarantee a win in subsequent turns anyway.</li>
            <li>Although the AI plays very well, this implementation still has room for improvement. Currently, if it can't guarantee a win, it will randomly pick between moves that can guarantee a draw, rather than trying to pick the "best" move between them like the <em>Hard</em> AI does.</li>
        </ul>
        <li><b>Loser:</b> Tries to lose. Also implemented using the minimax algorithm, so it behaves like <em>Hard</em>, but for a different goal.</li>
    </ul>
</p>
<p>
    Honestly, this project has become a lot more interesting than I expected because of all the different AI's that can be implemented. As a result, the codebase has become increasingly complex to accomodate the new ideas. Also, I'm interested in presenting these ideas with a much nicer UI.
</p>
<p>
    So maybe I'll spin this project off into something more serious? idk, not gonna make any promises though.
</p>

</body>
</html>

